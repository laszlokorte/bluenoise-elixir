<!-- livebook:{"app_settings":{"access_type":"public","auto_shutdown_ms":5000,"slug":"bluenoise"},"file_entries":[{"name":"girlperl.png","type":"attachment"}],"persist_outputs":true} -->

# Generating Blue Noise with Nx

```elixir
Mix.install([
  {:nx, "~> 0.10.0"},
  {:kino, "~> 0.18.0"},
  {:image, "~> 0.62.1"},
  {:kino_zoetrope, "~> 0.5.0"}
])

Kino.nothing()
```

## Preface

This livebook shows how to generate 2-dimensional Blue Noise via Elixir Nx.

This is a translation from Python Numpy to Elixir Nx of [the original Python/Numpy version](https://static.laszlokorte.de/blue-noise/)

## Introduction

[Video Demo](https://www.youtube.com/watch?v=ORsTjpy5CH8) | [Jupyter Notebook with further examples](https://github.com/laszlokorte/bluenoise-notebook/blob/main/bluenoise.ipynb) | [Interactive Web Page](https://static.laszlokorte.de/blue-noise/)

This is an interactive demonstration of the [Void and Cluster](https://ieeexplore.ieee.org/document/3288/) algorithm for generating blue noise. [There are](http://momentsingraphics.de/BlueNoise.html) already [plenty of](https://observablehq.com/@bensimonds/mitchells-best-candidate-algorithm) excellent explorations on [how](https://blog.demofox.org/2019/06/25/generating-blue-noise-textures-with-void-and-cluster/) [and why](https://www.youtube.com/watch?v=tethAU66xaA) to generate [blue noise](https://en.wikipedia.org/wiki/Colors_of_noise), [and noises of other color](https://blog.demofox.org/2017/10/25/transmuting-white-noise-to-blue-red-green-purple/). The _Void and Cluster_ algorithm is one of [several promiment algorithms](https://blog.demofox.org/2017/10/20/generating-blue-noise-sample-points-with-mitchells-best-candidate-algorithm/). [Some advantages](https://blog.demofox.org/2018/08/12/not-all-blue-noise-is-created-equal/) over other algorithms are that the blue noise is of very good quality and that only the first step in the algorithm is non-deterministic.

### This livebook

The goal of this livebook is to provide additional insight by visualizing the core idea of this algorithm.

This insight might be used to better understand the algorithm itself, for example to recognize potential performance improvements. But it might also be used as source of inspiration on how to design a custom algorithm. The algorithm below is implemented in Nx using an array oriented style. In this regard it can also be used as a case-study on how a sophisticated algorithm (that may [take multiple hundred lines in C++](https://github.com/Atrix256/VoidAndCluster/blob/master/generatebn_void_cluster.cpp)) can be written very succinctly when relying on higher level concepts, such as convolution and rank-polymorphism.

### Blue Noise

A sequence of random numbers is called _blue noise_ if succeeding numbers are very likely to be very different. This is in contrast to white noise, where each number would be completely unrelated to each other number in the squence. In a white noise sequency it would neither be surprising for the similar numbers occur right next to each other, nor would it be surprising for two succeeding values to be quite far appart. In blue noise neighbors are expected to be different. The opposite would be red noise, where neighboring values are expected to be at least similar.

The characteristic check if a sequence is _blue noise_ is to compute its [Power spectral density](https://en.wikipedia.org/wiki/Spectral_density#Power_spectral_density) (the magnitude-square of its Fourier Transform) and then to check that it contains only high frequencies.

### The algorithm

When generating 2D blue noise, as in the example below, the goal is to assign each pixel in the image a distinct intensity value, such that the intensity difference of neighboring pixels gets maximized.

Explore the code below…

<details>
  <summary>…or read the natural language explanation
</summary>

  The algorithm consists of multiple phases.

1.  **Initilization** (the only non-deterministic step, because of the `Nx.Random.uniform()` call):
    
    *   Generate white noise (`initial_white_noise`)
    *   Threshold the white noise to select a random subset (~10%) of pixels, as binary image (`placed_pixels`)

3.  **Phase1: Spreading**
    
    The randomly `placed_pixels` might be clustered in some areas and sparse in some other areas. This a because a un-correlated(white noise) random generator is used. To spread the pixels more evenly:
    
    *   Blur the `placed_pixels` with a gaussian filter to estimate the density across the image
    *   Move a `placed_pixel` from the highest densesity area to the most void empty position
    *   …repeat until dense and void areas converge

4.  **Phase 2: Assign distinct intensities to pixels**
    
    The random subset of `placed_pixels` is now spread as far as possible across the image.  
    Next we assign each of them a distinct intensity value (starting at 0) by iterating through the set in descending order:
    
    *   Blur the `placed_pixels`
    *   Select the pixel with highest density
    *   Assign a new intensity value to this pixel
    *   Repeat until each pixel in `placed_pixels` has been processed
5.  **Phase 3: Add remaining pixels**
    
    Up until now only a subset of the pixels (~10%) have been processed. To generate the remaining 90% of pixels:
    
    *   Blur the `placed_pixels`
    *   Select the empty pixel with lowest density
    *   Add this pixel to the `placed_pixels`
    *   Assign this pixel the next available intensity (`rank`) value in the output image
    *   …repeat until no more pixels left.
</details>

## Helper functions

Unfortunately some very basic signal processing tools are not included in the Nx package and must be defined manually.

```elixir
# Helper function to generate a Gaussian kernel
defmodule Gauss do 
  def kernel(size, sigma) do
    radius = div(size, 2)
    Nx.tensor(
      for y <- -radius..radius do
        for x <- -radius..radius do
          :math.exp(-(x*x + y*y)/(2*sigma*sigma))
        end
      end
    )
    |> then(&(Nx.divide(&1, Nx.sum(&1))))
  end
end

Gauss.kernel(32, 3) 
|> Nx.reshape({33,33, 1})
|> then(&Nx.divide(&1, Nx.reduce_max(&1)))
|> KinoZoetrope.TensorStack.new(titel: "Gaussian Kernel")
```

```elixir
# Helper function to apply cyclic padding to an image tensor
defmodule NxHelpers do  
  def cyclic_pad(t, pad_size) do
    h = elem(t.shape, 0)
    w = elem(t.shape, 1)

    # pad vertical
    top    = Nx.slice(t, [h - pad_size, 0], [pad_size, w])
    bottom = Nx.slice(t, [0, 0], [pad_size, w])
    t_vert = Nx.concatenate([top, t, bottom], axis: 0)

    # pad horizontal
    left  = Nx.slice(t_vert, [0, w - pad_size], [elem(t_vert.shape, 0), pad_size])
    right = Nx.slice(t_vert, [0, 0], [elem(t_vert.shape, 0), pad_size])
    
    Nx.concatenate([left, t_vert, right], axis: 1)
  end
end

Gauss.kernel(8, 2) 
|> NxHelpers.cyclic_pad(5)
|> then(&Nx.divide(&1, Nx.reduce_max(&1)))
|> KinoZoetrope.TensorStack.new(titel: "Gaussian Kernel with Cyclic Padding added", multiple: false)
```

## Initial Setup

First we define some intial parameters

```elixir
# Intitial random number generator
random_seed = Nx.Random.key(42)

Kino.nothing()
```

```elixir
# The size of the (square) noise image to generate
size = 32
# The ratio of pixel to initialize randomly in the beginning
initial_ratio = 0.1

# Size of the Gauss filter to use
gauss_size = 11 # how strong to blur the image for estimating maximum density
gauss_pad = div(gauss_size-1, 2) # Padding to apply before convoluton (half the kernel size)
gauss_kernel = Gauss.kernel(gauss_size, 1.8) # Prececulate gaussian kernel of dimension {1,1,w,h}
    |> Nx.new_axis(0)
    |> Nx.new_axis(0)

# Generate some initial uniform noise
{initial_white_noise, _new_key} = random_seed |> Nx.Random.uniform(shape: {size, size}, type: :f32)

Kino.nothing()
```

```elixir
# Take a look at this simple white noise.
# Each pixel has a random intensity value but you see some clustering
# caused by some pixel having the same value as their neighbours by pure chance.
initial_white_noise 
|> Nx.reshape({size,size, 1})
|> KinoZoetrope.TensorStack.new(titel: "Random White Noise")

# Our goal will be to get rid of this randomly occuring clustering
# while preserving the overall randomness of pixel values
```

## Threshold Initial Noise Map

```elixir
# turn uniform noise into binary (black/white, 1/0) image by thresholding
initial_placement = initial_white_noise |> Nx.greater(1-initial_ratio) |> Nx.flatten()

# initial white pixel
placed_pixels = initial_placement |> Nx.flatten()
# number of initially white pixels pixels
count_placed = Nx.sum(placed_pixels) |> Nx.to_number()
# number of initially black pixels
count_remaining = Nx.size(placed_pixels) - count_placed

Kino.nothing()
```

```elixir
# The initial random distribution of black and white pixels is not spaced evenly across the image
# there are some rather empty areas and some more densely populated areas.
placed_pixels
|> Nx.reshape({size, size}) 
|> KinoZoetrope.TensorStack.new(titel: "Thresholded White noise", multiple: false)
```

## Estimating Pixel Density via Blur

```elixir
# The average density of white pixels can be estimated by blurring the image
# Notice how in the blurred image there a some very bright and some very dark spots

placed_pixels
|> Nx.reshape({size, size}) 
|> NxHelpers.cyclic_pad(gauss_pad)
|> Nx.new_axis(0)
|> Nx.new_axis(0)
|> Nx.conv(gauss_kernel, padding: :valid)
|> Nx.reshape({size, size}) 
|> Nx.flatten() 
|> Nx.reshape({size,size})
|> then(&(Nx.divide(&1, Nx.reduce_max(&1))))
|> KinoZoetrope.TensorStack.new(titel: "Estimated pixel density", multiple: false, vmax: 1, vmin: 0)
```

## Phase 1: Swap Pixel from Densest with Pixel from Voidest Region

```elixir
# Next step:
# Iteratively swap the white pixels with black pixels to achive more evenly spaced 
# distribution of white pixels.

# Starting with the initial random placement white pixels
# we swap two pixels (one black and one white pixel) per iteration 
# until we can no longer improve the spacing
swaps = Stream.unfold({{nil, nil}, placed_pixels}, fn {prev_swap, placed} -> 
  # blur the white pixels to estimate the density overall density
  blurred = placed
    |> Nx.reshape({size, size}) 
    |> NxHelpers.cyclic_pad(gauss_pad)
    |> Nx.new_axis(0)
    |> Nx.new_axis(0)
    |> Nx.conv(gauss_kernel, padding: :valid)
    |> Nx.reshape({size, size}) 
    |> Nx.flatten() 


  # find the location of highest density (with the pixel itself at that location also being white)
  densest = Nx.multiply(blurred, placed) |> Nx.argmax(tie_break: :low) |> Nx.to_number()
  # and find the location of lowest density (with the pixel itself at the location being black)
  voidest = Nx.add(blurred, placed) |> Nx.argmin(tie_break: :low) |> Nx.to_number()

  # check if these two locations have already been swapped just before
  # to avoid cyclic swapping back and forth
  if prev_swap != {densest, voidest} and prev_swap != {voidest, densest} and densest != voidest do 

    # (We use `Nx.indexed_put` for setting indivual pixels and this function expects the index and value 
    # in some weird format)
    
    # prepare the indices for swapping
    swap_indices = Nx.tensor([densest, voidest]) |> Nx.new_axis(-1)
    # prepare the values for swapping
    swap_values = Nx.tensor([0, 1])
  
    # swap the pixel at the lowest density with the pixel at highest density
    updated = placed |> Nx.indexed_put(swap_indices, swap_values)

    # pass the updated image to the next iteration
    # and carry some debug information along
    {{{densest, voidest, blurred}, placed}, {{densest,voidest}, updated}}  
  else
    # stop iteration
    nil
  end
end)

# collect result of the last iteration and some debug data
{{_,_,debug_blurred}, not_ranked} = swaps 
# Continue with the result of the last iteration
|> Enum.at(-1)

Kino.nothing()
```

## Step through the Swap steps of Phase 1

```elixir
[
  
  swaps
|> Enum.map(fn {_, not_ranked} -> 
   not_ranked |> Nx.reshape({size,size})
  
  end)
|> Nx.concatenate()
  |> Nx.reshape({:auto,size,size}),
  swaps
|> Enum.map(fn {{_,_,blurred}, _} -> 
  b = blurred |> Nx.reshape({size,size}) |> Nx.as_type(:f32)
  max = Nx.reduce_max(b)
  b |> Nx.divide(max)
  end)
|> Nx.concatenate()
|> Nx.reshape({:auto,size,size,1}),
]
|> KinoZoetrope.TensorStack.new(
  titel: "Placed pixels (left) and Density estimation (right) after each swap", 
  normalize: true,
  vmin: 0,
  vmax: 1,
  labels: ["Placed Pixels", "Density"],
  markers: [
    %{
      attrs: %{
        "stroke" =>  "red",
        "stroke-width" => 2,
        "fill" => "none",
        "opacity" => 1,
      },
      for: [1],
      points: swaps |> Enum.map(fn {{densest, _, _}, _} -> 
           {densest |> rem(size), densest |> div(size)}
      end)
    },
    %{
      attrs: %{
        "stroke" =>  "lime",
        "stroke-width" => 2,
        "fill" => "none",
        "opacity" => 1,
      },
      for: [1],
      points: swaps |> Enum.map(fn {{_, voidest, _}, _} -> 
           {voidest |> rem(size), voidest |> div(size)}
      end)
    }
  ]
)


```

```elixir
# See how many iterations we took:
Enum.count(swaps) # 36 swaps on my machine when I last tried
```

<!-- livebook:{"output":true} -->

```
44
```

## White Pixels are evenly spaced now

```elixir
# Look now the distributions of white pixels is much better now!
# (same number of white pixels as before, but at other locations, spaced more evenly)
not_ranked
|> Nx.reshape({size,size, 1})
|> Nx.divide(Nx.reduce_max(not_ranked))
|> KinoZoetrope.TensorStack.new(titel: "Repositioned white pixels")
```

```elixir
# You can also see that the blurred image is much smoother
# ie. the distribution is more uniform
debug_blurred
|> Nx.reshape({size,size, 1})
|> Nx.divide(Nx.reduce_max(debug_blurred))
|> KinoZoetrope.TensorStack.new(
  titel: "Estimated pixel density after repositioning pixels", 
  vmax: 1.0, 
  vmin: 0.0
)
```

## Phase 2: Label the spaced out Pixels with incrementing Number

```elixir
# Next we want to number the white pixels uniquely with ascending integer values
# Since the white pixels are already spread quiet apart from eath other, no pixel
# will get a similar value as its direct neighbour.

# We call the value that we assign to a pixels its `rank`

# Starting with a new empty image for storing the rank
empty_ranks = Nx.broadcast(0, Nx.shape(initial_white_noise)) |> Nx.flatten()

# We iteratively remove one pixel after another, each time from the densest location
# and assign an incrementing label (rank) to its location in the empty image
# This gives us unique increasing pixel values with at least some spatial distance to each other
# in the resulting image
# We repeat this count_placed times since this is the number of white pixels we are able to pick and remove
{new_ranks, new_not_ranked, rank_debug_trace} = for rank <- count_placed..1//-1, reduce: {empty_ranks, not_ranked, []} do
  {ranks, not_ranked, debug_trace} ->
    # Blur the image of white pixels to estimate the density
    blurred = not_ranked
    |> Nx.reshape({size, size}) 
    |> NxHelpers.cyclic_pad(gauss_pad)
    |> Nx.new_axis(0)
    |> Nx.new_axis(0)
    |> Nx.conv(gauss_kernel, padding: :valid)
    |> Nx.flatten() 

    # find highest density (that has no rank assigned yet)
    densest = Nx.multiply(blurred, not_ranked) |> Nx.argmax(tie_break: :low)
    
    densest_indest = densest  |> Nx.new_axis(0) |> Nx.new_axis(0)

    # remove the pixel at the highest density location
    new_not_ranked = not_ranked
    |> Nx.indexed_put(densest_indest, Nx.tensor([0.0]))

    # insert increaing counter value (rank) at the same location in the new blank image
    new_ranks = ranks
    |> Nx.indexed_put(densest_indest, Nx.tensor([rank]))

    # continue with updated images until no white pixels are left to remove
    {new_ranks, new_not_ranked, [{ranks, not_ranked, blurred, Nx.to_number(densest)}|debug_trace]}
end

Kino.nothing()
```

## Replay the Steps from Phase 2

```elixir
[
  rank_debug_trace
|> Enum.map(fn {_, placed, _,_}  -> 
  placed |> Nx.reshape({size,size})
end)
|> Enum.reverse()
|> Nx.concatenate()
|> Nx.reshape({:auto,size,size,1}),
  rank_debug_trace
|> Enum.map(fn {_, _, blurred,_}  -> 
  blurred |> Nx.reshape({size,size})
end)
|> Enum.reverse()
|> Nx.concatenate()
|> Nx.reshape({:auto,size,size,1}),
  rank_debug_trace
|> Enum.map(fn {ranks, _, _,_}  -> 
  ranks  |> Nx.reshape({size,size})
  end)
|> Enum.reverse()
|> Nx.concatenate()
|> Nx.reshape({:auto, size, size,1})
]
|> KinoZoetrope.TensorStack.new(
  titel: "Unlabeled pixel (left) and Labeled Pixels (right)", 
  labels: ["Unranked Pixels", "Ranks"],
  markers: [
    %{
      attrs: %{
        "stroke" =>  "magenta",
        "stroke-width" => 2,
        "fill" => "none",
        "opacity" => 1,
      },
      for: [0,1,2],
      points: rank_debug_trace|> Enum.reverse() |> Enum.map(fn {_,_, _, densest} -> 
           {densest |> rem(size), densest |> div(size)}
      end)
    },
  ]
)
```

## Phase 2 Results

```elixir
# Look how we now have a well spaced out distributon of unique increasing values 
new_ranks
|> Nx.reshape({size,size, 1})
|> KinoZoetrope.TensorStack.new(titel: "Previously white pixels labeled with increasing value")

# But there are still many black pixels left.
# Assigning them a rank as well will be the next step
```

## Phase 3: Fill in the remaining pixels

```elixir
# To fill the remaining pixels we repeat the same iteration as before but now in reverse:
# Instead of picking locations of high density we pick locations of lowest density

# We know how many pixels the image has in total and how many pixels we did already process
# so we also know how many pixels are left: `count_remaining`
{final_ranks, final_placed, debug_trace} = for rank <- 0..count_remaining, reduce: {new_ranks, not_ranked, []}  do
  {ranks, placed, debug_steps} ->
    # Blur the image to estimate the density
    blurred = placed
    |> Nx.reshape({size, size}) 
    |> NxHelpers.cyclic_pad(gauss_pad)
    |> Nx.new_axis(0)
    |> Nx.new_axis(0)
    |> Nx.conv(gauss_kernel, padding: :valid)
    |> Nx.flatten() 

    # Pick the location of lowest density (that has now pixel placed yet)
    voidest = Nx.add(blurred, placed) |> Nx.argmin()
    
    voidest_indext = voidest |> Nx.new_axis(0)|> Nx.new_axis(0)

    # Add the pixel to the collection of placed pixels by setting it to 1 (white)
    updated_placed = placed
    |> Nx.indexed_put(voidest_indext, Nx.tensor([1.0]))

    # Assign a new rank value at this location
    updated_ranks = ranks
    |> Nx.indexed_put(voidest_indext, Nx.tensor([count_placed + rank]))

    # continue interation with updated ranks and placed pixels
    {updated_ranks, updated_placed, [{Nx.to_number(voidest), blurred, ranks, placed} | debug_steps]}
end

Kino.nothing()
```

## Replay the Steps from Phase 3

```elixir
[
debug_trace
|> Enum.map(fn {_voidest, _blurred, _ranks, placed}  -> 
  placed |> Nx.reshape({size,size})|> Nx.as_type(:f32)|> Nx.multiply(255) 
end)
  |>Enum.reverse()
|> Nx.concatenate()
|> Nx.reshape({:auto,size,size,1}),

debug_trace
|> Enum.map(fn {_voidest, blurred, _ranks, _placed}  -> 
  b = blurred |> Nx.reshape({size,size}) |> Nx.as_type(:f32)
  min = Nx.reduce_min(b)
  max = Nx.reduce_max(b)
  range = Nx.subtract(max, min) |> Nx.max(Nx.tensor(1.0e-12))
  b |> Nx.subtract(min) |> Nx.divide(range)  |> Nx.divide(2)  |> Nx.add(0.5) 
   |> Nx.multiply(255) 
  end)
  |>Enum.reverse()
|> Nx.concatenate()
|> Nx.reshape({:auto,size,size,1}),

  debug_trace
|> Enum.map(fn {_voidest, _blurred, ranks, _placed}  -> 
  ranks  |> Nx.reshape({size,size})
  end)
  |>Enum.reverse()
|> Nx.concatenate()
|> Nx.reshape({:auto,size,size,1})
]
|> KinoZoetrope.TensorStack.new(
  titel: "Placed Pixels (left), Density estimation (center) and Pixel labels (right)", 
  labels: ["Already Ranked Pixels", "Density Estimation", "Ranks"],
  markers: [
    %{
      attrs: %{
        "stroke" =>  "magenta",
        "stroke-width" => 2,
        "fill" => "none",
        "opacity" => 1,
      },
      for: [0,1,2],
      points: debug_trace|> Enum.reverse() |> Enum.map(fn {voidest, _, _, _} -> 
           {voidest |> rem(size), voidest |> div(size)}
      end)
    },
  ])
```

## Final Results

```elixir
# Now look at the final result:
# we have a 32x32 image (1024 pixels in total) with 1024 different pixel values
# evenly spaced out across the image
# Each pixel has a value (rank) that is very different from all its neighbour
# due to the order in which we assigned the values
final_ranks
|> Nx.reshape({size,size, 1})
# for display purposes we need to scale the pixels into a range 0-255
|> Nx.divide(Nx.reduce_max(final_ranks))
|> KinoZoetrope.TensorStack.new(titel: "Final normalized labeling (Blue Noise)")
```

```elixir
# Compare the result to our initial uniform random distribution of pixels: 
# In the intial distribution you can see light and dark clusters
initial_white_noise
|> Nx.reshape({size,size, 1})
|> KinoZoetrope.TensorStack.new(titel: "Original white noise with visible clusters")
```

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
# Lets try to threshold our result: setting only pixels to white whose value is above a certrain threshold. 
# Notice how only some of the pixel remain white (32/255) but they are evenly spaced out
# Try change the threshold to increase the number of white pixels and see how the spacing keeps nice
threshold = 16

final_ranks
|> Nx.divide(Nx.reduce_max(final_ranks))
|> Nx.multiply(255)
|> Nx.less(threshold)
|> Nx.reshape({size,size, 1})
|> KinoZoetrope.TensorStack.new(
  titel: "Thresholded Blue noise yields uniformly spaced white pixels"
)
```

```elixir
# Again contrast this with the thresholded original uniform noice distribution:
# the clustering is very obvious
threshold = 16

initial_white_noise
|> Nx.multiply(255)
|> Nx.less(16)
|> Nx.reshape({size,size, 1})
|> KinoZoetrope.TensorStack.new(
  titel: "Thresholded White Noise yields some dense and sparse spots"
)
```

## Example Application

The code below shows an example for how to use the generated blue noise.
We will use a technique called "1 sample per pixel convolution".
It is an alternative approach in which for the convolution only a single pixel from the source image is used to calculate an output image.
This is done be selecting pixels randomly from the source image.
Specifically we will use the previously generated blue noise to determine exactly which pixels to select.

[Further explanations for this appraoch can be found here](https://static.laszlokorte.de/sspp-conv/)

```elixir
# Sinc we want to blur an image, so we first generate a Gaussien kernel to convolve with
gauss_kernel = Gauss.kernel(7, 1)

gauss_kernel
|> Nx.reshape({7, 7}) 
|> KinoZoetrope.TensorStack.new(
  titel: "Some Gauss kernel for blurring an image", 
  multiple: false
)
```

```elixir
# Next we need an example image to work with. 
# We load an rgba png file from disk and convert to grayscale
{:ok, img} = Image.open(Kino.FS.file_path("girlperl.png"))
{:ok, bin} = Vix.Vips.Image.write_to_binary(img)

girl = bin |> Nx.from_binary(:u8) 
|> Nx.reshape({64, 64, 4}) 
# Discard alpha Channel
|> Nx.slice_along_axis(0, 3, axis: 2)
|> Nx.mean(axes: [2])
|> Nx.as_type(:u8)
|> Nx.reshape({64, 64, 1})

girl 
|> Nx.reshape({64, 64, 1})
|> KinoZoetrope.TensorStack.new(
  titel: "Example Image (The Girl with Perl skills)",
  vmin: 0,
  vmax: 255
)
```

```elixir
# In preparation for later sampling we interpret the 
# gaussian kernel as probablity density and calculate
# the cumulative distribution via 1D prefix sum (Nx.cumulative_sum)
{gw, gh} = Nx.shape(gauss_kernel)
cumulative_gaus = gauss_kernel |> Nx.flatten() |> Nx.cumulative_sum()

# The top left most pixel is black and 
# the bottom right most pixel is white
cumulative_gaus 
# We can simplify the 2-dim kernel to 1 dimension because
# we just need to use it for sampling a single coord via a single
# random value
|> Nx.reshape({gw, gh, 1})
|> KinoZoetrope.TensorStack.new(
  titel: "1D cumulated Gauss kernel"
)
```

```elixir
# Retreive dimensions of the gauss kernel...
{gw,gh} = Nx.shape(gauss_kernel)
# ... and the input image 
{h, w, _} = Nx.shape(girl)

# convert our generated blue noise (final_ranks) into square shape and into range 0..1
noise_source = final_ranks 
  |> Nx.reshape({size,size, 1}) 
  |> then(&Nx.divide(&1, Nx.reduce_max(&1)))
{n_h, n_w} = {size,size}

# Generate array of size {h,w} containing indicies into the noise source {n_h, n_w}
x = Nx.iota({h, w}, axis: 0) |> Nx.remainder(n_w) # x coord
y = Nx.iota({h, w}, axis: 1) |> Nx.remainder(n_h) # y coord
# flatten index
idx = x |> Nx.multiply(n_w) |> Nx.add(y)

# sample the noise texture (our generated blue nosie) at each index position
noise_values = noise_source
|> Nx.reshape({n_h * n_w, 1})
|> Nx.take(idx)
|> Nx.reshape({h, w, 1})

# For each sampled value select an index in the cumulative distribution
# via Inverse transform sampling
# Specifically: select the first index in the cumdist where the element is greater than our
# random sample value
sample_index = Nx.greater_equal(
  Nx.reshape(noise_values, {:auto, 1}), 
  Nx.reshape(cumulative_gaus, {1, :auto})
) |> Nx.argmin(axis: 1)

# Convert the sampled index from the kernel
# into and x offset
offset_x = sample_index 
  |> Nx.remainder(gw)
  # subtracting half the kernel width
  |> Nx.subtract(Nx.divide(Nx.subtract(gw, 1), 2)) 
  |> Nx.as_type({:s,8}) 

# and an y offset
offset_y = sample_index 
  |> Nx.subtract(offset_x) 
  |> Nx.divide(gw) 
  # subtracting half the kernel height
  |> Nx.subtract(Nx.divide(Nx.subtract(gh, 1), 2)) 
  |> Nx.as_type({:s,8})

# Generate x and y indices into our image and offset each of them
# by one our generated offset values
# (we generated exactly as many x and y offsets as there are pixels in our original image)
sx = Nx.iota({h, w}, axis: 0) 
  |> Nx.add(Nx.reshape(offset_x, {h, w})) 
  |> Nx.remainder(w) 
  |> Nx.add(w) 
  |> Nx.remainder(w) 
sy = Nx.iota({h, w}, axis: 1) 
  |> Nx.add(Nx.reshape(offset_y, {h, w})) 
  |> Nx.remainder(h) 
  |> Nx.add(h) 
  |>Nx.remainder(h) 

# convert x and y coordinates into a flat coordinate
sidx = sx |> Nx.multiply(w) |> Nx.add(sy)

result = girl
|> Nx.reshape({h * w, 1})
|> Nx.take(sidx)
|> Nx.reshape({h, w, 1})

# Show the result
result
|> Nx.reshape({h, w, 1})
|> KinoZoetrope.TensorStack.new(
  titel: "Image Blurred via 1SSP Convolution with Blue Noise as Random Source",
  vmin: 0,
  vmax: 255
)

```

```elixir
# Instead of actually sampling our input image we can
# also plot the sampling coordinates themself
sidx
|> Nx.reshape({h * w, 1})
|> Nx.take(sidx)
|> Nx.reshape({h, w, 1})
|> KinoZoetrope.TensorStack.new(titel: "The coordinate values",
  vmin: 0,
  vmax: w*h
)
```

```elixir
# Same as above but with multiple different Gauss kernels in comparious
kernel_sizes = [0.1, 0.3, 0.5, 0.8, 1.0, 1.2, 1.5, 2.0,2.2, 2.5,3.0]

for stddev <- kernel_sizes do 
  gauss_kernel = Gauss.kernel(7, max(stddev, 0.01))
  cumulative_gaus = gauss_kernel |> Nx.flatten() |> Nx.cumulative_sum()
  
  # Retreive dimensions of the gauss kernel...
  {gw,gh} = Nx.shape(gauss_kernel)
  # ... and the input image 
  {h, w, _} = Nx.shape(girl)
  
  # convert our generated blue noise (final_ranks) into square shape and into range 0..1
  noise_source = final_ranks 
    |> Nx.reshape({size,size, 1}) 
    |> then(&Nx.divide(&1, Nx.reduce_max(&1)))
  {n_h, n_w} = {size,size}
  
  # Generate array of size {h,w} containing indicies into the noise source {n_h, n_w}
  x = Nx.iota({h, w}, axis: 0) |> Nx.remainder(n_w) # x coord
  y = Nx.iota({h, w}, axis: 1) |> Nx.remainder(n_h) # y coord
  # flatten index
  idx = x |> Nx.multiply(n_w) |> Nx.add(y)
  
  # sample the noise texture (our generated blue nosie) at each index position
  noise_values = noise_source
  |> Nx.reshape({n_h * n_w, 1})
  |> Nx.take(idx)
  |> Nx.reshape({h, w, 1})
  
  # For each sampled value select an index in the cumulative distribution
  # via Inverse transform sampling
  # Specifically: select the first index in the cumdist where the element is greater than our
  # random sample value
  sample_index = Nx.greater_equal(
    Nx.reshape(noise_values, {:auto, 1}), 
    Nx.reshape(cumulative_gaus, {1, :auto})
  ) |> Nx.argmin(axis: 1)
  
  # Convert the sampled index from the kernel
  # into and x offset
  offset_x = sample_index 
    |> Nx.remainder(gw)
    # subtracting half the kernel width
    |> Nx.subtract(Nx.divide(Nx.subtract(gw, 1), 2)) 
    |> Nx.as_type({:s,8}) 
  
  # and an y offset
  offset_y = sample_index 
    |> Nx.subtract(offset_x) 
    |> Nx.divide(gw) 
    # subtracting half the kernel height
    |> Nx.subtract(Nx.divide(Nx.subtract(gh, 1), 2)) 
    |> Nx.as_type({:s,8})
  
  # Generate x and y indices into our image and offset each of them
  # by one our generated offset values
  # (we generated exactly as many x and y offsets as there are pixels in our original image)
  sx = Nx.iota({h, w}, axis: 0) 
    |> Nx.add(Nx.reshape(offset_x, {h, w})) 
    |> Nx.remainder(w) 
    |> Nx.add(w) 
    |> Nx.remainder(w) 
  sy = Nx.iota({h, w}, axis: 1) 
    |> Nx.add(Nx.reshape(offset_y, {h, w})) 
    |> Nx.remainder(h) 
    |> Nx.add(h) 
    |> Nx.remainder(h) 
  # convert x and y coordinates into a flat coordinate
  sidx = sx |> Nx.multiply(w) |> Nx.add(sy)
  
  girl
    |> Nx.reshape({h * w, 1})
    |> Nx.take(sidx)
    |> Nx.reshape({h, w, 1})
end
# Prepend original image
|> then(&[girl|&1])
# Stack all results together to show them at once
|> Nx.stack()
|> then(&[girl,&1])
|> KinoZoetrope.TensorStack.new(
  titel: "Image Blurred via 1SSP Convolution with differently sized Gaussian kernels",
  labels: ["Original", "Blurred"],
  vmin: 0,
  vmax: 255
)

```
